# "Elite" C64 disassembly / "Elite DX", cc0 2018, see LICENSE.txt
# "Elite" is copyright / trademark David Braben & Ian Bell, All Rights Reserved
# <github.com/Kroc/EliteDX>
#===============================================================================

"""\
A script to 'encrypt' (scramble would be a better word), a binary for inclusion in the original GMA86 loader.

The 'encryption' is done by simply adding one byte to the next and saving the resultant byte. for example, the following original data:

    $4c, $32, $24, $00, $03, $60, $6b, $a9, ...

is encoded by adding $4c and $32 = $7e, then $32 + $24, $24 + $00, and so on giving: (values > $ff just wrap-around)

    $7e, $56, $24, $03, $63, $cb, $14, ...

This requires that there be three extra 'junk' padding bytes on the end to ensure that all the actual data is encoded.

The final caluclated value is the 'decryption key', used to reverse the process.
"""

import argparse

parser = argparse.ArgumentParser(description="A script to 'encrypt' (scramble would be a better word), a binary for inclusion in the original GMA86 loader.")

parser.add_argument("--prg",
    help="if present, ignore a PRG file header",
    action="store_true")
parser.add_argument("infile", help="input file")
parser.add_argument("outfile", help="output file")

args = parser.parse_args()

infile = open(args.infile, "rb").read()

with open(args.outfile, "w") as outfile:
    # write out the assembly file header
    outfile.writelines("""\
; "Elite" C64 disassembly / "Elite DX", cc0 2018, see LICENSE.txt
; "Elite" is copyright / trademark David Braben & Ian Bell, All Rights Reserved
; <github.com/Kroc/EliteDX>
;===============================================================================
; this file is automatically generated by ecnrypt.py -- DO NOT MODIFY DIRECTLY
""")
    # which byte we're on (also, which byte we start from)
    byte = 0
    # we'll batch bytes up into groups of 8 per line
    count = 0

    # should we skip a PRG header?
    # (two bytes that specify load address)
    if args.prg: byte += 2

    # walk along the bytes in the input file
    for i in range(byte, len(infile) - 1):
        # should we start a new line?
        if count == 0:
            outfile.write("\n.byte   ")
        else:
            outfile.write(", ")
        
        # pair bytes together
        out = int(infile[i]) + int(infile[i+1])
        # ensure bytes wrap around
        if out > 255:
            out = out - 256
        # write to the output file
        outfile.write("$%0.2x" % out)

        count = (count + 1) % 8

    outfile.write("\n\n")

    print(":          decrypt key =", "$%0.2x" % out)
